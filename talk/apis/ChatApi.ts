/* tslint:disable */
/* eslint-disable */
/**
 * spreed
 * Chat, video & audio-conferencing using WebRTC
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime.ts';
import type {
  AvatarUploadAvatar200Response,
  BanBanActor400Response,
  BanUnbanActor200Response,
  CallJoinCall400Response,
  ChatClearHistory200Response,
  ChatGetObjectsSharedInRoom200Response,
  ChatGetObjectsSharedInRoomOverview200Response,
  ChatGetReminder200Response,
  ChatMentions200Response,
  ChatReceiveMessages200Response,
  ChatSendMessage201Response,
} from '../models/index.ts';
import {
    AvatarUploadAvatar200ResponseFromJSON,
    AvatarUploadAvatar200ResponseToJSON,
    BanBanActor400ResponseFromJSON,
    BanBanActor400ResponseToJSON,
    BanUnbanActor200ResponseFromJSON,
    BanUnbanActor200ResponseToJSON,
    CallJoinCall400ResponseFromJSON,
    CallJoinCall400ResponseToJSON,
    ChatClearHistory200ResponseFromJSON,
    ChatClearHistory200ResponseToJSON,
    ChatGetObjectsSharedInRoom200ResponseFromJSON,
    ChatGetObjectsSharedInRoom200ResponseToJSON,
    ChatGetObjectsSharedInRoomOverview200ResponseFromJSON,
    ChatGetObjectsSharedInRoomOverview200ResponseToJSON,
    ChatGetReminder200ResponseFromJSON,
    ChatGetReminder200ResponseToJSON,
    ChatMentions200ResponseFromJSON,
    ChatMentions200ResponseToJSON,
    ChatReceiveMessages200ResponseFromJSON,
    ChatReceiveMessages200ResponseToJSON,
    ChatSendMessage201ResponseFromJSON,
    ChatSendMessage201ResponseToJSON,
} from '../models/index.ts';

export interface ChatClearHistoryRequest {
    apiVersion: ChatClearHistoryApiVersionEnum;
    token: string;
    oCSAPIRequest: boolean;
}

export interface ChatDeleteMessageRequest {
    apiVersion: ChatDeleteMessageApiVersionEnum;
    token: string;
    messageId: number;
    oCSAPIRequest: boolean;
}

export interface ChatDeleteReminderRequest {
    apiVersion: ChatDeleteReminderApiVersionEnum;
    token: string;
    messageId: number;
    oCSAPIRequest: boolean;
}

export interface ChatEditMessageRequest {
    message: string;
    apiVersion: ChatEditMessageApiVersionEnum;
    token: string;
    messageId: number;
    oCSAPIRequest: boolean;
}

export interface ChatGetMessageContextRequest {
    apiVersion: ChatGetMessageContextApiVersionEnum;
    token: string;
    messageId: number;
    oCSAPIRequest: boolean;
    limit?: number;
}

export interface ChatGetObjectsSharedInRoomRequest {
    objectType: string;
    apiVersion: ChatGetObjectsSharedInRoomApiVersionEnum;
    token: string;
    oCSAPIRequest: boolean;
    lastKnownMessageId?: number;
    limit?: number;
}

export interface ChatGetObjectsSharedInRoomOverviewRequest {
    apiVersion: ChatGetObjectsSharedInRoomOverviewApiVersionEnum;
    token: string;
    oCSAPIRequest: boolean;
    limit?: number;
}

export interface ChatGetReminderRequest {
    apiVersion: ChatGetReminderApiVersionEnum;
    token: string;
    messageId: number;
    oCSAPIRequest: boolean;
}

export interface ChatMarkUnreadRequest {
    apiVersion: ChatMarkUnreadApiVersionEnum;
    token: string;
    oCSAPIRequest: boolean;
}

export interface ChatMentionsRequest {
    search: string;
    apiVersion: ChatMentionsApiVersionEnum;
    token: string;
    oCSAPIRequest: boolean;
    limit?: number;
    includeStatus?: ChatMentionsIncludeStatusEnum;
}

export interface ChatReceiveMessagesRequest {
    lookIntoFuture: ChatReceiveMessagesLookIntoFutureEnum;
    apiVersion: ChatReceiveMessagesApiVersionEnum;
    token: string;
    oCSAPIRequest: boolean;
    limit?: number;
    lastKnownMessageId?: number;
    lastCommonReadId?: number;
    timeout?: number;
    setReadMarker?: ChatReceiveMessagesSetReadMarkerEnum;
    includeLastKnown?: ChatReceiveMessagesIncludeLastKnownEnum;
    noStatusUpdate?: ChatReceiveMessagesNoStatusUpdateEnum;
    markNotificationsAsRead?: ChatReceiveMessagesMarkNotificationsAsReadEnum;
}

export interface ChatSendMessageRequest {
    message: string;
    apiVersion: ChatSendMessageApiVersionEnum;
    token: string;
    oCSAPIRequest: boolean;
    actorDisplayName?: string;
    referenceId?: string;
    replyTo?: number;
    silent?: ChatSendMessageSilentEnum;
}

export interface ChatSetReadMarkerRequest {
    apiVersion: ChatSetReadMarkerApiVersionEnum;
    token: string;
    oCSAPIRequest: boolean;
    lastReadMessage?: number;
}

export interface ChatSetReminderRequest {
    timestamp: number;
    apiVersion: ChatSetReminderApiVersionEnum;
    token: string;
    messageId: number;
    oCSAPIRequest: boolean;
}

export interface ChatShareObjectToChatRequest {
    objectType: string;
    objectId: string;
    apiVersion: ChatShareObjectToChatApiVersionEnum;
    token: string;
    oCSAPIRequest: boolean;
    metaData?: string;
    actorDisplayName?: string;
    referenceId?: string;
}

/**
 * 
 */
export class ChatApi extends runtime.BaseAPI {

    /**
     * Clear the chat history
     */
    async chatClearHistoryRaw(requestParameters: ChatClearHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatClearHistory200Response>> {
        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling chatClearHistory().'
            );
        }

        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling chatClearHistory().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling chatClearHistory().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/chat/{token}`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters['token']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatClearHistory200ResponseFromJSON(jsonValue));
    }

    /**
     * Clear the chat history
     */
    async chatClearHistory(requestParameters: ChatClearHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatClearHistory200Response> {
        const response = await this.chatClearHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a chat message
     */
    async chatDeleteMessageRaw(requestParameters: ChatDeleteMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatSendMessage201Response>> {
        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling chatDeleteMessage().'
            );
        }

        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling chatDeleteMessage().'
            );
        }

        if (requestParameters['messageId'] == null) {
            throw new runtime.RequiredError(
                'messageId',
                'Required parameter "messageId" was null or undefined when calling chatDeleteMessage().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling chatDeleteMessage().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/chat/{token}/{messageId}`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters['token']))).replace(`{${"messageId"}}`, encodeURIComponent(String(requestParameters['messageId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatSendMessage201ResponseFromJSON(jsonValue));
    }

    /**
     * Delete a chat message
     */
    async chatDeleteMessage(requestParameters: ChatDeleteMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatSendMessage201Response> {
        const response = await this.chatDeleteMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a chat reminder
     */
    async chatDeleteReminderRaw(requestParameters: ChatDeleteReminderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CallJoinCall400Response>> {
        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling chatDeleteReminder().'
            );
        }

        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling chatDeleteReminder().'
            );
        }

        if (requestParameters['messageId'] == null) {
            throw new runtime.RequiredError(
                'messageId',
                'Required parameter "messageId" was null or undefined when calling chatDeleteReminder().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling chatDeleteReminder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/chat/{token}/{messageId}/reminder`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters['token']))).replace(`{${"messageId"}}`, encodeURIComponent(String(requestParameters['messageId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CallJoinCall400ResponseFromJSON(jsonValue));
    }

    /**
     * Delete a chat reminder
     */
    async chatDeleteReminder(requestParameters: ChatDeleteReminderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CallJoinCall400Response> {
        const response = await this.chatDeleteReminderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit a chat message
     */
    async chatEditMessageRaw(requestParameters: ChatEditMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatSendMessage201Response>> {
        if (requestParameters['message'] == null) {
            throw new runtime.RequiredError(
                'message',
                'Required parameter "message" was null or undefined when calling chatEditMessage().'
            );
        }

        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling chatEditMessage().'
            );
        }

        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling chatEditMessage().'
            );
        }

        if (requestParameters['messageId'] == null) {
            throw new runtime.RequiredError(
                'messageId',
                'Required parameter "messageId" was null or undefined when calling chatEditMessage().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling chatEditMessage().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['message'] != null) {
            queryParameters['message'] = requestParameters['message'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/chat/{token}/{messageId}`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters['token']))).replace(`{${"messageId"}}`, encodeURIComponent(String(requestParameters['messageId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatSendMessage201ResponseFromJSON(jsonValue));
    }

    /**
     * Edit a chat message
     */
    async chatEditMessage(requestParameters: ChatEditMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatSendMessage201Response> {
        const response = await this.chatEditMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the context of a message
     */
    async chatGetMessageContextRaw(requestParameters: ChatGetMessageContextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatReceiveMessages200Response>> {
        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling chatGetMessageContext().'
            );
        }

        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling chatGetMessageContext().'
            );
        }

        if (requestParameters['messageId'] == null) {
            throw new runtime.RequiredError(
                'messageId',
                'Required parameter "messageId" was null or undefined when calling chatGetMessageContext().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling chatGetMessageContext().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/chat/{token}/{messageId}/context`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters['token']))).replace(`{${"messageId"}}`, encodeURIComponent(String(requestParameters['messageId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatReceiveMessages200ResponseFromJSON(jsonValue));
    }

    /**
     * Get the context of a message
     */
    async chatGetMessageContext(requestParameters: ChatGetMessageContextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatReceiveMessages200Response> {
        const response = await this.chatGetMessageContextRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get objects that are shared in the room
     */
    async chatGetObjectsSharedInRoomRaw(requestParameters: ChatGetObjectsSharedInRoomRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatGetObjectsSharedInRoom200Response>> {
        if (requestParameters['objectType'] == null) {
            throw new runtime.RequiredError(
                'objectType',
                'Required parameter "objectType" was null or undefined when calling chatGetObjectsSharedInRoom().'
            );
        }

        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling chatGetObjectsSharedInRoom().'
            );
        }

        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling chatGetObjectsSharedInRoom().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling chatGetObjectsSharedInRoom().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['objectType'] != null) {
            queryParameters['objectType'] = requestParameters['objectType'];
        }

        if (requestParameters['lastKnownMessageId'] != null) {
            queryParameters['lastKnownMessageId'] = requestParameters['lastKnownMessageId'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/chat/{token}/share`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters['token']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatGetObjectsSharedInRoom200ResponseFromJSON(jsonValue));
    }

    /**
     * Get objects that are shared in the room
     */
    async chatGetObjectsSharedInRoom(requestParameters: ChatGetObjectsSharedInRoomRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatGetObjectsSharedInRoom200Response> {
        const response = await this.chatGetObjectsSharedInRoomRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get objects that are shared in the room overview
     */
    async chatGetObjectsSharedInRoomOverviewRaw(requestParameters: ChatGetObjectsSharedInRoomOverviewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatGetObjectsSharedInRoomOverview200Response>> {
        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling chatGetObjectsSharedInRoomOverview().'
            );
        }

        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling chatGetObjectsSharedInRoomOverview().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling chatGetObjectsSharedInRoomOverview().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/chat/{token}/share/overview`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters['token']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatGetObjectsSharedInRoomOverview200ResponseFromJSON(jsonValue));
    }

    /**
     * Get objects that are shared in the room overview
     */
    async chatGetObjectsSharedInRoomOverview(requestParameters: ChatGetObjectsSharedInRoomOverviewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatGetObjectsSharedInRoomOverview200Response> {
        const response = await this.chatGetObjectsSharedInRoomOverviewRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the reminder for a chat message
     */
    async chatGetReminderRaw(requestParameters: ChatGetReminderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatGetReminder200Response>> {
        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling chatGetReminder().'
            );
        }

        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling chatGetReminder().'
            );
        }

        if (requestParameters['messageId'] == null) {
            throw new runtime.RequiredError(
                'messageId',
                'Required parameter "messageId" was null or undefined when calling chatGetReminder().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling chatGetReminder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/chat/{token}/{messageId}/reminder`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters['token']))).replace(`{${"messageId"}}`, encodeURIComponent(String(requestParameters['messageId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatGetReminder200ResponseFromJSON(jsonValue));
    }

    /**
     * Get the reminder for a chat message
     */
    async chatGetReminder(requestParameters: ChatGetReminderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatGetReminder200Response> {
        const response = await this.chatGetReminderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mark a chat as unread
     */
    async chatMarkUnreadRaw(requestParameters: ChatMarkUnreadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AvatarUploadAvatar200Response>> {
        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling chatMarkUnread().'
            );
        }

        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling chatMarkUnread().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling chatMarkUnread().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/chat/{token}/read`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters['token']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AvatarUploadAvatar200ResponseFromJSON(jsonValue));
    }

    /**
     * Mark a chat as unread
     */
    async chatMarkUnread(requestParameters: ChatMarkUnreadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AvatarUploadAvatar200Response> {
        const response = await this.chatMarkUnreadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for mentions
     */
    async chatMentionsRaw(requestParameters: ChatMentionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatMentions200Response>> {
        if (requestParameters['search'] == null) {
            throw new runtime.RequiredError(
                'search',
                'Required parameter "search" was null or undefined when calling chatMentions().'
            );
        }

        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling chatMentions().'
            );
        }

        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling chatMentions().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling chatMentions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['includeStatus'] != null) {
            queryParameters['includeStatus'] = requestParameters['includeStatus'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/chat/{token}/mentions`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters['token']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatMentions200ResponseFromJSON(jsonValue));
    }

    /**
     * Search for mentions
     */
    async chatMentions(requestParameters: ChatMentionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatMentions200Response> {
        const response = await this.chatMentionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * - Receiving the history ($lookIntoFuture=0): The next $limit messages after $lastKnownMessageId will be returned. The new $lastKnownMessageId for the follow up query is available as `X-Chat-Last-Given` header. - Looking into the future ($lookIntoFuture=1): If there are currently no messages the response will not be sent immediately. Instead, HTTP connection will be kept open waiting for new messages to arrive and, when they do, then the response will be sent. The connection will not be kept open indefinitely, though; the number of seconds to wait for new messages to arrive can be set using the timeout parameter; the default timeout is 30 seconds, maximum timeout is 60 seconds. If the timeout ends a successful but empty response will be sent. If messages have been returned (status=200) the new $lastKnownMessageId for the follow up query is available as `X-Chat-Last-Given` header. The limit specifies the maximum number of messages that will be returned, although the actual number of returned messages could be lower if some messages are not visible to the participant. Note that if none of the messages are visible to the participant the returned number of messages will be 0, yet the status will still be 200. Also note that `X-Chat-Last-Given` may reference a message not visible and thus not returned, but it should be used nevertheless as the $lastKnownMessageId for the follow-up query.
     * Receives chat messages from the given room
     */
    async chatReceiveMessagesRaw(requestParameters: ChatReceiveMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatReceiveMessages200Response>> {
        if (requestParameters['lookIntoFuture'] == null) {
            throw new runtime.RequiredError(
                'lookIntoFuture',
                'Required parameter "lookIntoFuture" was null or undefined when calling chatReceiveMessages().'
            );
        }

        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling chatReceiveMessages().'
            );
        }

        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling chatReceiveMessages().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling chatReceiveMessages().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['lookIntoFuture'] != null) {
            queryParameters['lookIntoFuture'] = requestParameters['lookIntoFuture'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['lastKnownMessageId'] != null) {
            queryParameters['lastKnownMessageId'] = requestParameters['lastKnownMessageId'];
        }

        if (requestParameters['lastCommonReadId'] != null) {
            queryParameters['lastCommonReadId'] = requestParameters['lastCommonReadId'];
        }

        if (requestParameters['timeout'] != null) {
            queryParameters['timeout'] = requestParameters['timeout'];
        }

        if (requestParameters['setReadMarker'] != null) {
            queryParameters['setReadMarker'] = requestParameters['setReadMarker'];
        }

        if (requestParameters['includeLastKnown'] != null) {
            queryParameters['includeLastKnown'] = requestParameters['includeLastKnown'];
        }

        if (requestParameters['noStatusUpdate'] != null) {
            queryParameters['noStatusUpdate'] = requestParameters['noStatusUpdate'];
        }

        if (requestParameters['markNotificationsAsRead'] != null) {
            queryParameters['markNotificationsAsRead'] = requestParameters['markNotificationsAsRead'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/chat/{token}`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters['token']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatReceiveMessages200ResponseFromJSON(jsonValue));
    }

    /**
     * - Receiving the history ($lookIntoFuture=0): The next $limit messages after $lastKnownMessageId will be returned. The new $lastKnownMessageId for the follow up query is available as `X-Chat-Last-Given` header. - Looking into the future ($lookIntoFuture=1): If there are currently no messages the response will not be sent immediately. Instead, HTTP connection will be kept open waiting for new messages to arrive and, when they do, then the response will be sent. The connection will not be kept open indefinitely, though; the number of seconds to wait for new messages to arrive can be set using the timeout parameter; the default timeout is 30 seconds, maximum timeout is 60 seconds. If the timeout ends a successful but empty response will be sent. If messages have been returned (status=200) the new $lastKnownMessageId for the follow up query is available as `X-Chat-Last-Given` header. The limit specifies the maximum number of messages that will be returned, although the actual number of returned messages could be lower if some messages are not visible to the participant. Note that if none of the messages are visible to the participant the returned number of messages will be 0, yet the status will still be 200. Also note that `X-Chat-Last-Given` may reference a message not visible and thus not returned, but it should be used nevertheless as the $lastKnownMessageId for the follow-up query.
     * Receives chat messages from the given room
     */
    async chatReceiveMessages(requestParameters: ChatReceiveMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatReceiveMessages200Response> {
        const response = await this.chatReceiveMessagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The author and timestamp are automatically set to the current user/guest and time.
     * Sends a new chat message to the given room
     */
    async chatSendMessageRaw(requestParameters: ChatSendMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatSendMessage201Response>> {
        if (requestParameters['message'] == null) {
            throw new runtime.RequiredError(
                'message',
                'Required parameter "message" was null or undefined when calling chatSendMessage().'
            );
        }

        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling chatSendMessage().'
            );
        }

        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling chatSendMessage().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling chatSendMessage().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['message'] != null) {
            queryParameters['message'] = requestParameters['message'];
        }

        if (requestParameters['actorDisplayName'] != null) {
            queryParameters['actorDisplayName'] = requestParameters['actorDisplayName'];
        }

        if (requestParameters['referenceId'] != null) {
            queryParameters['referenceId'] = requestParameters['referenceId'];
        }

        if (requestParameters['replyTo'] != null) {
            queryParameters['replyTo'] = requestParameters['replyTo'];
        }

        if (requestParameters['silent'] != null) {
            queryParameters['silent'] = requestParameters['silent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/chat/{token}`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters['token']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatSendMessage201ResponseFromJSON(jsonValue));
    }

    /**
     * The author and timestamp are automatically set to the current user/guest and time.
     * Sends a new chat message to the given room
     */
    async chatSendMessage(requestParameters: ChatSendMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatSendMessage201Response> {
        const response = await this.chatSendMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set the read marker to a specific message
     */
    async chatSetReadMarkerRaw(requestParameters: ChatSetReadMarkerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AvatarUploadAvatar200Response>> {
        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling chatSetReadMarker().'
            );
        }

        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling chatSetReadMarker().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling chatSetReadMarker().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['lastReadMessage'] != null) {
            queryParameters['lastReadMessage'] = requestParameters['lastReadMessage'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/chat/{token}/read`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters['token']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AvatarUploadAvatar200ResponseFromJSON(jsonValue));
    }

    /**
     * Set the read marker to a specific message
     */
    async chatSetReadMarker(requestParameters: ChatSetReadMarkerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AvatarUploadAvatar200Response> {
        const response = await this.chatSetReadMarkerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set a reminder for a chat message
     */
    async chatSetReminderRaw(requestParameters: ChatSetReminderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatGetReminder200Response>> {
        if (requestParameters['timestamp'] == null) {
            throw new runtime.RequiredError(
                'timestamp',
                'Required parameter "timestamp" was null or undefined when calling chatSetReminder().'
            );
        }

        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling chatSetReminder().'
            );
        }

        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling chatSetReminder().'
            );
        }

        if (requestParameters['messageId'] == null) {
            throw new runtime.RequiredError(
                'messageId',
                'Required parameter "messageId" was null or undefined when calling chatSetReminder().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling chatSetReminder().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['timestamp'] != null) {
            queryParameters['timestamp'] = requestParameters['timestamp'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/chat/{token}/{messageId}/reminder`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters['token']))).replace(`{${"messageId"}}`, encodeURIComponent(String(requestParameters['messageId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatGetReminder200ResponseFromJSON(jsonValue));
    }

    /**
     * Set a reminder for a chat message
     */
    async chatSetReminder(requestParameters: ChatSetReminderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatGetReminder200Response> {
        const response = await this.chatSetReminderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The author and timestamp are automatically set to the current user/guest and time.
     * Sends a rich-object to the given room
     */
    async chatShareObjectToChatRaw(requestParameters: ChatShareObjectToChatRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatSendMessage201Response>> {
        if (requestParameters['objectType'] == null) {
            throw new runtime.RequiredError(
                'objectType',
                'Required parameter "objectType" was null or undefined when calling chatShareObjectToChat().'
            );
        }

        if (requestParameters['objectId'] == null) {
            throw new runtime.RequiredError(
                'objectId',
                'Required parameter "objectId" was null or undefined when calling chatShareObjectToChat().'
            );
        }

        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling chatShareObjectToChat().'
            );
        }

        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling chatShareObjectToChat().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling chatShareObjectToChat().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['objectType'] != null) {
            queryParameters['objectType'] = requestParameters['objectType'];
        }

        if (requestParameters['objectId'] != null) {
            queryParameters['objectId'] = requestParameters['objectId'];
        }

        if (requestParameters['metaData'] != null) {
            queryParameters['metaData'] = requestParameters['metaData'];
        }

        if (requestParameters['actorDisplayName'] != null) {
            queryParameters['actorDisplayName'] = requestParameters['actorDisplayName'];
        }

        if (requestParameters['referenceId'] != null) {
            queryParameters['referenceId'] = requestParameters['referenceId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/chat/{token}/share`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters['token']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatSendMessage201ResponseFromJSON(jsonValue));
    }

    /**
     * The author and timestamp are automatically set to the current user/guest and time.
     * Sends a rich-object to the given room
     */
    async chatShareObjectToChat(requestParameters: ChatShareObjectToChatRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatSendMessage201Response> {
        const response = await this.chatShareObjectToChatRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ChatClearHistoryApiVersionEnum = {
    V1: 'v1'
} as const;
export type ChatClearHistoryApiVersionEnum = typeof ChatClearHistoryApiVersionEnum[keyof typeof ChatClearHistoryApiVersionEnum];
/**
 * @export
 */
export const ChatDeleteMessageApiVersionEnum = {
    V1: 'v1'
} as const;
export type ChatDeleteMessageApiVersionEnum = typeof ChatDeleteMessageApiVersionEnum[keyof typeof ChatDeleteMessageApiVersionEnum];
/**
 * @export
 */
export const ChatDeleteReminderApiVersionEnum = {
    V1: 'v1'
} as const;
export type ChatDeleteReminderApiVersionEnum = typeof ChatDeleteReminderApiVersionEnum[keyof typeof ChatDeleteReminderApiVersionEnum];
/**
 * @export
 */
export const ChatEditMessageApiVersionEnum = {
    V1: 'v1'
} as const;
export type ChatEditMessageApiVersionEnum = typeof ChatEditMessageApiVersionEnum[keyof typeof ChatEditMessageApiVersionEnum];
/**
 * @export
 */
export const ChatGetMessageContextApiVersionEnum = {
    V1: 'v1'
} as const;
export type ChatGetMessageContextApiVersionEnum = typeof ChatGetMessageContextApiVersionEnum[keyof typeof ChatGetMessageContextApiVersionEnum];
/**
 * @export
 */
export const ChatGetObjectsSharedInRoomApiVersionEnum = {
    V1: 'v1'
} as const;
export type ChatGetObjectsSharedInRoomApiVersionEnum = typeof ChatGetObjectsSharedInRoomApiVersionEnum[keyof typeof ChatGetObjectsSharedInRoomApiVersionEnum];
/**
 * @export
 */
export const ChatGetObjectsSharedInRoomOverviewApiVersionEnum = {
    V1: 'v1'
} as const;
export type ChatGetObjectsSharedInRoomOverviewApiVersionEnum = typeof ChatGetObjectsSharedInRoomOverviewApiVersionEnum[keyof typeof ChatGetObjectsSharedInRoomOverviewApiVersionEnum];
/**
 * @export
 */
export const ChatGetReminderApiVersionEnum = {
    V1: 'v1'
} as const;
export type ChatGetReminderApiVersionEnum = typeof ChatGetReminderApiVersionEnum[keyof typeof ChatGetReminderApiVersionEnum];
/**
 * @export
 */
export const ChatMarkUnreadApiVersionEnum = {
    V1: 'v1'
} as const;
export type ChatMarkUnreadApiVersionEnum = typeof ChatMarkUnreadApiVersionEnum[keyof typeof ChatMarkUnreadApiVersionEnum];
/**
 * @export
 */
export const ChatMentionsApiVersionEnum = {
    V1: 'v1'
} as const;
export type ChatMentionsApiVersionEnum = typeof ChatMentionsApiVersionEnum[keyof typeof ChatMentionsApiVersionEnum];
/**
 * @export
 */
export const ChatMentionsIncludeStatusEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;
export type ChatMentionsIncludeStatusEnum = typeof ChatMentionsIncludeStatusEnum[keyof typeof ChatMentionsIncludeStatusEnum];
/**
 * @export
 */
export const ChatReceiveMessagesLookIntoFutureEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;
export type ChatReceiveMessagesLookIntoFutureEnum = typeof ChatReceiveMessagesLookIntoFutureEnum[keyof typeof ChatReceiveMessagesLookIntoFutureEnum];
/**
 * @export
 */
export const ChatReceiveMessagesApiVersionEnum = {
    V1: 'v1'
} as const;
export type ChatReceiveMessagesApiVersionEnum = typeof ChatReceiveMessagesApiVersionEnum[keyof typeof ChatReceiveMessagesApiVersionEnum];
/**
 * @export
 */
export const ChatReceiveMessagesSetReadMarkerEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;
export type ChatReceiveMessagesSetReadMarkerEnum = typeof ChatReceiveMessagesSetReadMarkerEnum[keyof typeof ChatReceiveMessagesSetReadMarkerEnum];
/**
 * @export
 */
export const ChatReceiveMessagesIncludeLastKnownEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;
export type ChatReceiveMessagesIncludeLastKnownEnum = typeof ChatReceiveMessagesIncludeLastKnownEnum[keyof typeof ChatReceiveMessagesIncludeLastKnownEnum];
/**
 * @export
 */
export const ChatReceiveMessagesNoStatusUpdateEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;
export type ChatReceiveMessagesNoStatusUpdateEnum = typeof ChatReceiveMessagesNoStatusUpdateEnum[keyof typeof ChatReceiveMessagesNoStatusUpdateEnum];
/**
 * @export
 */
export const ChatReceiveMessagesMarkNotificationsAsReadEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;
export type ChatReceiveMessagesMarkNotificationsAsReadEnum = typeof ChatReceiveMessagesMarkNotificationsAsReadEnum[keyof typeof ChatReceiveMessagesMarkNotificationsAsReadEnum];
/**
 * @export
 */
export const ChatSendMessageApiVersionEnum = {
    V1: 'v1'
} as const;
export type ChatSendMessageApiVersionEnum = typeof ChatSendMessageApiVersionEnum[keyof typeof ChatSendMessageApiVersionEnum];
/**
 * @export
 */
export const ChatSendMessageSilentEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;
export type ChatSendMessageSilentEnum = typeof ChatSendMessageSilentEnum[keyof typeof ChatSendMessageSilentEnum];
/**
 * @export
 */
export const ChatSetReadMarkerApiVersionEnum = {
    V1: 'v1'
} as const;
export type ChatSetReadMarkerApiVersionEnum = typeof ChatSetReadMarkerApiVersionEnum[keyof typeof ChatSetReadMarkerApiVersionEnum];
/**
 * @export
 */
export const ChatSetReminderApiVersionEnum = {
    V1: 'v1'
} as const;
export type ChatSetReminderApiVersionEnum = typeof ChatSetReminderApiVersionEnum[keyof typeof ChatSetReminderApiVersionEnum];
/**
 * @export
 */
export const ChatShareObjectToChatApiVersionEnum = {
    V1: 'v1'
} as const;
export type ChatShareObjectToChatApiVersionEnum = typeof ChatShareObjectToChatApiVersionEnum[keyof typeof ChatShareObjectToChatApiVersionEnum];
