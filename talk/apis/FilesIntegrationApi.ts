/* tslint:disable */
/* eslint-disable */
/**
 * spreed
 * Chat, video & audio-conferencing using WebRTC
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime.ts';
import type {
  BanUnbanActor200Response,
  FilesIntegrationGetRoomByFileId200Response,
  FilesIntegrationGetRoomByShareToken200Response,
  PublicShareAuthCreateRoom201Response,
} from '../models/index.ts';
import {
    BanUnbanActor200ResponseFromJSON,
    BanUnbanActor200ResponseToJSON,
    FilesIntegrationGetRoomByFileId200ResponseFromJSON,
    FilesIntegrationGetRoomByFileId200ResponseToJSON,
    FilesIntegrationGetRoomByShareToken200ResponseFromJSON,
    FilesIntegrationGetRoomByShareToken200ResponseToJSON,
    PublicShareAuthCreateRoom201ResponseFromJSON,
    PublicShareAuthCreateRoom201ResponseToJSON,
} from '../models/index.ts';

export interface FilesIntegrationGetRoomByFileIdRequest {
    apiVersion: FilesIntegrationGetRoomByFileIdApiVersionEnum;
    fileId: string;
    oCSAPIRequest: boolean;
}

export interface FilesIntegrationGetRoomByShareTokenRequest {
    apiVersion: FilesIntegrationGetRoomByShareTokenApiVersionEnum;
    shareToken: string;
    oCSAPIRequest: boolean;
}

export interface PublicShareAuthCreateRoomRequest {
    shareToken: string;
    apiVersion: PublicShareAuthCreateRoomApiVersionEnum;
    oCSAPIRequest: boolean;
}

/**
 * 
 */
export class FilesIntegrationApi extends runtime.BaseAPI {

    /**
     * This is the counterpart of self::getRoomByShareToken() for file ids instead of share tokens, although both return the same room token if the given file id and share token refer to the same file. If there is no room associated to the given file id a new room is created; the new room is a public room associated with a \"file\" object with the given file id. Unlike normal rooms in which the owner is the user that created the room these are special rooms without owner (although self joined users with direct access to the file become persistent participants automatically when they join until they explicitly leave or no longer have access to the file). In any case, to create or even get the token of the room, the file must be shared and the user must be the owner of a public share of the file (like a link share, for example) or have direct access to that file; an error is returned otherwise. A user has direct access to a file if she has access to it (or to an ancestor) through a user, group, circle or room share (but not through a link share, for example), or if she is the owner of such a file.
     * Get the token of the room associated to the given file id
     */
    async filesIntegrationGetRoomByFileIdRaw(requestParameters: FilesIntegrationGetRoomByFileIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FilesIntegrationGetRoomByFileId200Response>> {
        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling filesIntegrationGetRoomByFileId().'
            );
        }

        if (requestParameters['fileId'] == null) {
            throw new runtime.RequiredError(
                'fileId',
                'Required parameter "fileId" was null or undefined when calling filesIntegrationGetRoomByFileId().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling filesIntegrationGetRoomByFileId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/file/{fileId}`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))).replace(`{${"fileId"}}`, encodeURIComponent(String(requestParameters['fileId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FilesIntegrationGetRoomByFileId200ResponseFromJSON(jsonValue));
    }

    /**
     * This is the counterpart of self::getRoomByShareToken() for file ids instead of share tokens, although both return the same room token if the given file id and share token refer to the same file. If there is no room associated to the given file id a new room is created; the new room is a public room associated with a \"file\" object with the given file id. Unlike normal rooms in which the owner is the user that created the room these are special rooms without owner (although self joined users with direct access to the file become persistent participants automatically when they join until they explicitly leave or no longer have access to the file). In any case, to create or even get the token of the room, the file must be shared and the user must be the owner of a public share of the file (like a link share, for example) or have direct access to that file; an error is returned otherwise. A user has direct access to a file if she has access to it (or to an ancestor) through a user, group, circle or room share (but not through a link share, for example), or if she is the owner of such a file.
     * Get the token of the room associated to the given file id
     */
    async filesIntegrationGetRoomByFileId(requestParameters: FilesIntegrationGetRoomByFileIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FilesIntegrationGetRoomByFileId200Response> {
        const response = await this.filesIntegrationGetRoomByFileIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This is the counterpart of self::getRoomByFileId() for share tokens instead of file ids, although both return the same room token if the given file id and share token refer to the same file. If there is no room associated to the file id of the given share token a new room is created; the new room is a public room associated with a \"file\" object with the file id of the given share token. Unlike normal rooms in which the owner is the user that created the room these are special rooms without owner (although self joined users with direct access to the file become persistent participants automatically when they join until they explicitly leave or no longer have access to the file). In any case, to create or even get the token of the room, the file must be publicly shared (like a link share, for example); an error is returned otherwise. Besides the token of the room this also returns the current user ID and display name, if any; this is needed by the Talk sidebar to know the actual current user, as the public share page uses the incognito mode and thus logged-in users as seen as guests.
     * Returns the token of the room associated to the file of the given share token
     */
    async filesIntegrationGetRoomByShareTokenRaw(requestParameters: FilesIntegrationGetRoomByShareTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FilesIntegrationGetRoomByShareToken200Response>> {
        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling filesIntegrationGetRoomByShareToken().'
            );
        }

        if (requestParameters['shareToken'] == null) {
            throw new runtime.RequiredError(
                'shareToken',
                'Required parameter "shareToken" was null or undefined when calling filesIntegrationGetRoomByShareToken().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling filesIntegrationGetRoomByShareToken().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/publicshare/{shareToken}`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))).replace(`{${"shareToken"}}`, encodeURIComponent(String(requestParameters['shareToken']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FilesIntegrationGetRoomByShareToken200ResponseFromJSON(jsonValue));
    }

    /**
     * This is the counterpart of self::getRoomByFileId() for share tokens instead of file ids, although both return the same room token if the given file id and share token refer to the same file. If there is no room associated to the file id of the given share token a new room is created; the new room is a public room associated with a \"file\" object with the file id of the given share token. Unlike normal rooms in which the owner is the user that created the room these are special rooms without owner (although self joined users with direct access to the file become persistent participants automatically when they join until they explicitly leave or no longer have access to the file). In any case, to create or even get the token of the room, the file must be publicly shared (like a link share, for example); an error is returned otherwise. Besides the token of the room this also returns the current user ID and display name, if any; this is needed by the Talk sidebar to know the actual current user, as the public share page uses the incognito mode and thus logged-in users as seen as guests.
     * Returns the token of the room associated to the file of the given share token
     */
    async filesIntegrationGetRoomByShareToken(requestParameters: FilesIntegrationGetRoomByShareTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FilesIntegrationGetRoomByShareToken200Response> {
        const response = await this.filesIntegrationGetRoomByShareTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The new room is a public room associated with a \"share:password\" object with the ID of the share token. Unlike normal rooms in which the owner is the user that created the room these are special rooms always created by a guest or user on behalf of a registered user, the sharer, who will be the owner of the room. The share must have \"send password by Talk\" enabled; an error is returned otherwise.
     * Creates a new room for video verification (requesting the password of a share)
     */
    async publicShareAuthCreateRoomRaw(requestParameters: PublicShareAuthCreateRoomRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicShareAuthCreateRoom201Response>> {
        if (requestParameters['shareToken'] == null) {
            throw new runtime.RequiredError(
                'shareToken',
                'Required parameter "shareToken" was null or undefined when calling publicShareAuthCreateRoom().'
            );
        }

        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling publicShareAuthCreateRoom().'
            );
        }

        if (requestParameters['oCSAPIRequest'] == null) {
            throw new runtime.RequiredError(
                'oCSAPIRequest',
                'Required parameter "oCSAPIRequest" was null or undefined when calling publicShareAuthCreateRoom().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['shareToken'] != null) {
            queryParameters['shareToken'] = requestParameters['shareToken'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['oCSAPIRequest'] != null) {
            headerParameters['OCS-APIRequest'] = String(requestParameters['oCSAPIRequest']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ocs/v2.php/apps/spreed/api/{apiVersion}/publicshareauth`.replace(`{${"apiVersion"}}`, encodeURIComponent(String(requestParameters['apiVersion']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicShareAuthCreateRoom201ResponseFromJSON(jsonValue));
    }

    /**
     * The new room is a public room associated with a \"share:password\" object with the ID of the share token. Unlike normal rooms in which the owner is the user that created the room these are special rooms always created by a guest or user on behalf of a registered user, the sharer, who will be the owner of the room. The share must have \"send password by Talk\" enabled; an error is returned otherwise.
     * Creates a new room for video verification (requesting the password of a share)
     */
    async publicShareAuthCreateRoom(requestParameters: PublicShareAuthCreateRoomRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicShareAuthCreateRoom201Response> {
        const response = await this.publicShareAuthCreateRoomRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const FilesIntegrationGetRoomByFileIdApiVersionEnum = {
    V1: 'v1'
} as const;
export type FilesIntegrationGetRoomByFileIdApiVersionEnum = typeof FilesIntegrationGetRoomByFileIdApiVersionEnum[keyof typeof FilesIntegrationGetRoomByFileIdApiVersionEnum];
/**
 * @export
 */
export const FilesIntegrationGetRoomByShareTokenApiVersionEnum = {
    V1: 'v1'
} as const;
export type FilesIntegrationGetRoomByShareTokenApiVersionEnum = typeof FilesIntegrationGetRoomByShareTokenApiVersionEnum[keyof typeof FilesIntegrationGetRoomByShareTokenApiVersionEnum];
/**
 * @export
 */
export const PublicShareAuthCreateRoomApiVersionEnum = {
    V1: 'v1'
} as const;
export type PublicShareAuthCreateRoomApiVersionEnum = typeof PublicShareAuthCreateRoomApiVersionEnum[keyof typeof PublicShareAuthCreateRoomApiVersionEnum];
